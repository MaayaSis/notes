<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>Maaya</title>
	<style type='text/css'>
		/*使用 对象.事件 = 函数的形式绑定响应函数
		 *它只能同时为一个元素的一个事件绑定一个响应函数
		 *不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的
		 *addEventListener()
		 * -通过这个方法也可以为元素绑定响应函数
		 * -参数：1.事件的字符串，不要on 2.回调函数，当事件触发时该函数会被调用 3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false
		 *addEventListener()可以同时为一个元素的相同事件绑定多个响应函数，这样当事件被触发时，响应函数将会按顺序进行
		 *但是不支持IE8及以下的浏览器
		 *attachEvent支持
		 * -参数：1.事件的字符串，要on 2.回调函数 
		 *这个方法也可以同时为一个事件绑定多个处理函数，不同的是他是后绑定先执行，执行顺序和addEventListener()相反
		 *
		 *定义一个函数，用来为指定元素绑定响应函数
		 * -参数：
		 * -obj要绑定事件的对象
		 * -eventStr 事件的字符串
		 * -callback 返回函数
		 *
		 */
	</style>
	<script type='text/javascript'>
		/*
		 *
		 */
		window.onload = function () {
			var btn01 = document.getElementById('btn01');
			btn01.addEventListener('click', function () {
				alert(1);
			}, false);
			//this是绑定事件的对象
			btn01.addEventListener('click', function () {
				alert(this);
			}, false);
			//这是支持IE8及以下的attachListener,顺序是反的，如果一定要按顺序出现，那么可以写在一起
			btn01.attachEvent('onclcik', function () {
				alert.log(this);
			});
			//
			bind(btn01,'click',function(){
				alert(3);
			})
			function bind(obj, eventStr, callback) {
				//如果有的话，就会返回一个对象，对象转换成一个布尔值，那就是true
				//两个this不相同，要统一,我们使用匿名函数调用callback回调函数，这样我们就可以通过.call()修改调用者this
				if (obj.addEventListener) {
					obj.addEventListener(eventStr, callback, false);
				} else { obj.attachEvent('on' + eventStr, function(){
					callback.call(obj);
				}); }
			}
		}
	</script>

<body>
	<!-- 
		-->
	<button id="btn01">点我一下</button>
</body>

</html>